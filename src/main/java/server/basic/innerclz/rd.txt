Q:匿名内部类持有的外部变量应用类型为什么要final
A:因为内部类拷贝了一份外部类的引用，那么就会有数据不一致的问题，有可能内部类悄悄改了变量，而外部

定义为final，是否会对gc造成影响呢？比如说无法gc的情形。

大体来讲是会影响，但要看内部类的对象的声明周期，所以不必担心。分两种情况，首先如果final 原生类型(int long double等等，这个例子里面是int position)
 因为是值拷贝，是在栈上，所以没有回收的问题；其次如果final的对象，也就是new出来的，因为放在堆上，在这个例子里，final变量被new AnimatorListener()
 这个对象引用，可以理解成作为这个对象里面的的成员变量了，这个Listener对象一旦没有被别人引用了，那么这时候final的对象就可以被回收了。

“position如果不是final的，回调的时候肯定就无法拿到它的值了” 这句话完全是不正确的解释。
final的值会做拷贝，final的对象在堆上，如果有引用，是不会被回收的。
所以内部匿名类的用外面的变量要加final，其实是一个闭包的解决方案的问题，
程序员不希望在外面变量改变的时候，里面的值没有变，这样是反知觉的，所以java干脆把这样的变量设计成final，
一旦初始化，就必须不能改变！这样保证内外使用这个变量的时候感觉是一个对象。

事实上，除了匿名内部类内部，方法和作用域内的内部类内部使用的外部变量也必须是 final 的,这是闭包导致的
//作用域内的需要final
  public static void main(String[] args) {
  final  int b;
        {
            class A{
                b = 2;
            }
        }
  }
  //方法内部的内部类也需要final
    public void a(){
        final  int b;
          class A{
              b = 2;
          }
      }